// This file was generated by counterfeiter
package projectfakes

import (
	"sync"

	go_tracker "github.com/odlp/go-tracker"
	"github.com/odlp/inflight/project"
)

type FakeUserCacheInterface struct {
	TryFindUserStub        func(email string) *go_tracker.ProjectMembership
	tryFindUserMutex       sync.RWMutex
	tryFindUserArgsForCall []struct {
		email string
	}
	tryFindUserReturns struct {
		result1 *go_tracker.ProjectMembership
	}
	CacheFoundUserStub        func(email, initials string)
	cacheFoundUserMutex       sync.RWMutex
	cacheFoundUserArgsForCall []struct {
		email    string
		initials string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserCacheInterface) TryFindUser(email string) *go_tracker.ProjectMembership {
	fake.tryFindUserMutex.Lock()
	fake.tryFindUserArgsForCall = append(fake.tryFindUserArgsForCall, struct {
		email string
	}{email})
	fake.recordInvocation("TryFindUser", []interface{}{email})
	fake.tryFindUserMutex.Unlock()
	if fake.TryFindUserStub != nil {
		return fake.TryFindUserStub(email)
	} else {
		return fake.tryFindUserReturns.result1
	}
}

func (fake *FakeUserCacheInterface) TryFindUserCallCount() int {
	fake.tryFindUserMutex.RLock()
	defer fake.tryFindUserMutex.RUnlock()
	return len(fake.tryFindUserArgsForCall)
}

func (fake *FakeUserCacheInterface) TryFindUserArgsForCall(i int) string {
	fake.tryFindUserMutex.RLock()
	defer fake.tryFindUserMutex.RUnlock()
	return fake.tryFindUserArgsForCall[i].email
}

func (fake *FakeUserCacheInterface) TryFindUserReturns(result1 *go_tracker.ProjectMembership) {
	fake.TryFindUserStub = nil
	fake.tryFindUserReturns = struct {
		result1 *go_tracker.ProjectMembership
	}{result1}
}

func (fake *FakeUserCacheInterface) CacheFoundUser(email string, initials string) {
	fake.cacheFoundUserMutex.Lock()
	fake.cacheFoundUserArgsForCall = append(fake.cacheFoundUserArgsForCall, struct {
		email    string
		initials string
	}{email, initials})
	fake.recordInvocation("CacheFoundUser", []interface{}{email, initials})
	fake.cacheFoundUserMutex.Unlock()
	if fake.CacheFoundUserStub != nil {
		fake.CacheFoundUserStub(email, initials)
	}
}

func (fake *FakeUserCacheInterface) CacheFoundUserCallCount() int {
	fake.cacheFoundUserMutex.RLock()
	defer fake.cacheFoundUserMutex.RUnlock()
	return len(fake.cacheFoundUserArgsForCall)
}

func (fake *FakeUserCacheInterface) CacheFoundUserArgsForCall(i int) (string, string) {
	fake.cacheFoundUserMutex.RLock()
	defer fake.cacheFoundUserMutex.RUnlock()
	return fake.cacheFoundUserArgsForCall[i].email, fake.cacheFoundUserArgsForCall[i].initials
}

func (fake *FakeUserCacheInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.tryFindUserMutex.RLock()
	defer fake.tryFindUserMutex.RUnlock()
	fake.cacheFoundUserMutex.RLock()
	defer fake.cacheFoundUserMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeUserCacheInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ project.UserCacheInterface = new(FakeUserCacheInterface)
